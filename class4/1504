# #1054
# 문제
# 방향성이 없는 그래프가 주어진다. 세준이는 1번 정점에서 N번 정점으로 최단 거리로 이동하려고 한다. 또한 세준이는 두 가지 조건을 만족하면서 이동하는 특정한 최단 경로를 구하고 싶은데, 그것은 바로 임의로 주어진 두 정점은 반드시 통과해야 한다는 것이다.

# 세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에 정점의 개수 N과 간선의 개수 E가 주어진다. (2 ≤ N ≤ 800, 0 ≤ E ≤ 200,000) 둘째 줄부터 E개의 줄에 걸쳐서 세 개의 정수 a, b, c가 주어지는데, a번 정점에서 b번 정점까지 양방향 길이 존재하며, 그 거리가 c라는 뜻이다. (1 ≤ c ≤ 1,000) 다음 줄에는 반드시 거쳐야 하는 두 개의 서로 다른 정점 번호 v1과 v2가 주어진다. (v1 ≠ v2, v1 ≠ N, v2 ≠ 1) 임의의 두 정점 u와 v사이에는 간선이 최대 1개 존재한다.

# 출력
# 첫째 줄에 두 개의 정점을 지나는 최단 경로의 길이를 출력한다. 그러한 경로가 없을 때에는 -1을 출력한다.


from collections import deque
# 정점과 간선 받아주기
N,E=map(int,input().split())

graph= [[]for i in range(N+1)]
for i in range(E):
    node1,node2,leng=map(int,input().split())
    graph[node1].append((node2,leng))
    graph[node2].append((node1,leng))



queue=deque()
# 데이크스트라 함수 개설
def daykstra(start, end):
    #dv는 그 노드의 거리를 저장
    dv=[1e9]*(N+1)
    #방문 했는지에 대한것 저장
    visited=[-1]*(N+1)
    
    dv[start] = 0
    queue.append(start)
    #BFS를 이용하여 풀기
    while queue:
        cnt_node = queue.popleft()
        
        for adj_node,adj_dist in graph[cnt_node]:
            # 만약 방문하지 않았다면
            if visited[adj_node] == -1:
                #queue에 추가해주고
                queue.append(adj_node)
                #만약 거리가 더 적은게 계산되면 바꿔주고
                if dv[adj_node] >  dv[cnt_node]+adj_dist:
                    dv[adj_node]=dv[cnt_node]+adj_dist
        visited[cnt_node]=1
        # end에오면 return
        if cnt_node == end:
            return dv[end]
        

A,B = map(int,input().split())       
print(daykstra(1,A))
print(daykstra(1,B))
print(daykstra(A,B))
print(daykstra(N,A))
print(daykstra(N,B))


# 으엑  틀렸다. 왜지?
# 찾아보니 BFS가 아니라 힙이라는 자료구조로 풀던데 함 찾아봐야겠다.
